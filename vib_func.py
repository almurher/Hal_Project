from unicodedata import category
from bs4 import BeautifulSoup
import pandas as pd
from typing import final


'''DATA EXTRACTION'''

def report_types():
    # Type of reports generated by the inSite platform.
    
    return ['Detailed Vibration Report', 'Operating Limit Summary Report']

def report_categ_ind(soup_file):
    # Returns an index based on the file type of category.

    title_tag = str(soup_file.h1)
    category_list = report_types()
    for cat in category_list:
        if cat in title_tag:
            return category_list.index(cat)

def info_parser(soup_file, table_ind: int):
    # Returns a list (or dictionary?) with the parsed information of the well or the analysis report.
    # through the use of the BeautifulSoup.find_all() method it extracts all the tags inside the html

    table_tag = soup_file.find_all("table")[table_ind]
    row_tag = table_tag.find_all("tr")

    final_lst = []
    for tr in row_tag:
        cell_lst = []

        for td in tr:
            if td.name:
                cell_lst.append(td.string)

        final_lst.append(str(x) for x in cell_lst)

    return dict(final_lst)

def vib_val_extr(parent_div):

    final_lst = []

    # Extract values from thead tags.
    thead_list = []
    for td in parent_div.thead.tr:
        if td.name:
            thead_list.append(str(td.string))

    final_lst.append(thead_list)

    # Extract values from tbody tags.
    for tr in parent_div.tbody:
        if tr.name:
            td_list = []

            for td in tr:
                if td.name:
                    td_list.append(str(td.string))

            final_lst.append(td_list)

    return final_lst

def vol_summary_extr(soup_file, file_category_ind):
    # Returns a datastructure with the parsed values from the vibrating
    # operating limit summary. It takes as parameter the soup from each xls
    # file and the table index 3.
    # Also, it's composed of two functions...

    value_lst = []
    table_ind = file_category_ind + 2
    table_tag = soup_file.find_all("table")[table_ind]

    div_tag = table_tag.find_all("div")
    for div in div_tag:
        if div.name:
            value_lst.append([str(div.string), vib_val_extr(div.parent)])

    return value_lst

def data_helper(well_df, vols_df):
    # Note: It's not used anymore.
    # Helper function for vib_val_df(), returns a dictionary with the needed information from the
    # the well and the vibration operating limit summary.

    info_needed = ["Well Name", "Job Number", "Run Number selected", "Vibration Tool", "M/LWD Tool Size"]
    new_dct = {}

    for info in info_needed:
        if info in well_df.columns:
            new_dct[info] = well_df.loc[0, info]
        elif info in vols_df.columns:
            new_dct[info] = vols_df.loc[0, info]

    return new_dct

'''CREATING DATAFRAMES'''

def row_merger(df_lst):
    # Help to merge rows
    new_df_lst = []
    peak_df_merged = {}

    for df in df_lst:
        string_name = str(df.loc[0, "Measure Type"]).split()
        if "Peak" in string_name:
            key_p = string_name[1]
            if key_p not in peak_df_merged:
                peak_df_merged[key_p] = [df]

            else:
                peak_df_merged[key_p].append(df)

        else:
            new_df_lst.append(df)

    if len(peak_df_merged) > 0:
            for v in peak_df_merged.values():
                if len(v) > 1:
                    v[0] = v[0].combine_first(v[1]) 

                new_df_lst.append(v[0])

    return new_df_lst

def vib_val_df(vib_val_list):
    # Function that returns a dataframe from the list of lists from vol_summary_extr
    # merged with other data like job number, run, sensor and even tool size for average bins.

    copy_lst = vib_val_list.copy()
    # df = pd.DataFrame([extrainfo_dict])
    # df.drop(columns = "Well Name", inplace = True)
    new_list = []

    for v_lst in copy_lst:
        header = v_lst[1].pop(0)

        v_df = pd.DataFrame(v_lst[1], columns = header)
        v_df.insert(0, "Measure Type", v_lst[0])
        v_df.iloc[:, 2] = [float(x) for x in v_df.iloc[:, 2]]
        new_list.append(v_df)

    final_list = row_merger(new_list)

    return final_list

def info_merger_df(well_dict, vols_dict):
    # It takes both well information and the vibration operating limits summary
    # information data structures and returns a merged dataframe.

    well_copy = well_dict.copy()
    well_copy.update(vols_dict)
    
    # If needed here the dataframe can be cleaned for a future update...
    df = pd.DataFrame([well_copy])
    return df

def final_merger_df(well_dict, vols_dict, vib_val_dict_df):
    # Returns the raw final dataframe for this file.
    fin_df = pd.DataFrame()
    well_copy = well_dict.copy()
    well_copy.update(vols_dict)
    key_list = list(well_copy.keys())
    value_list = list(well_copy.values())

    for df in vib_val_dict_df:
        temp_df = df.copy()
        for i in range(len(key_list) - 1, -1, -1):
            temp_df.insert(0, key_list[i], value_list[i])

        fin_df = pd.concat([fin_df, temp_df]).reset_index(drop = True)
    
    return fin_df


'''DATA CLEANING'''

def df_modifier(df, file_category):
    
    # This function integers different functions related to modify the final
    # dataframe. it's only purpose is give more order to the script.

    del_av_bin_neg(df, file_category)
    column_eraser(df, file_category)
    
def column_eraser(df, file_category):
    # Deletes columns that are considered useless for either reports.
    col_stnd = ['Rig Name','Activity Code', 'Report Generation Date and Time']
    col_stnd.extend(col_to_del(file_category))
    df.drop(columns=col_stnd, inplace=True)

def col_to_del(file_category):

    valid = report_types()
    if file_category not in valid:
        raise ValueError(f'Resultados: status debe ser una opci√≥n de {valid.join()}')
    
    if file_category == valid[0]:
        # Columns considered not useful for a Detailed Vibration Report.
        return ['Depth Range selected', 'Date/Time Range selected']

        # Columns considered not useful for a Operating Limit Summary Report.
    return ['GP RPM Filter Min Value', 'GP RPM Filter Max Value']
    
def del_av_bin_neg(df, file_category):

    # Reports contain two tables with "Delta Average Bins" however one of them has
    # negative Bands (G) so this function add a "(-)" to differenciate between each
    # table.
    valid = report_types()
    if file_category == valid[1]:
        filt = df['Band (G)'].str.contains('-', na=False)
        df.loc[filt, 'Measure Type'] = 'Delta Average Bins (-)'


    